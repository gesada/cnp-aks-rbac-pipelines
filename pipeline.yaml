#
# Build for the RPE PoCs AKS Cluster
#
name: RPE AKS RBAC Enabled Pipeline
trigger: none
variables:
  aksResourceGroup: ''
  aksVnetCidr: ''
  aksSubnetCidr: ''
  aksServiceCidr: ''
  aksDnsServiceIp: ''
  keyvaultName: rpe-infra
  serviceConnection: azurerm-rpetemp
  helmVersion: '2.12.0'
  location: 'UK South'
  adminNamespace: 'admin'
  aadSelector: 'mi'
  aadMicVersion: '1.3'
  aadNmiVersion: '1.4'
  kvFlexVolumeVersion: 'v0.0.8'

jobs:
- job: Keyvault
  pool:
    vmImage: 'Ubuntu 16.04'
  steps:
  - task: AzureKeyVault@1
    displayName: 'Get secrets from Keyvault'
    inputs:
      azureSubscription: $(serviceConnection)
      keyVaultName: $(keyvaultName)
      secretsFilter: 'aks-sp-secret,aks-sapp-secret'
  - script: |
      echo "##vso[task.setvariable variable=aksServicePrincipalSecret;isOutput=true]$(aks-sp-secret)"
      echo "##vso[task.setvariable variable=aksServerAppSecret;isOutput=true]$(aks-sapp-secret)"
    displayName: 'Export Keyvault Variables'
    name: exportKeyvault

- job: DeployAKS
  dependsOn: Keyvault
  pool:
    vmImage: 'Ubuntu 16.04'
  variables:
    aksClusterName: $(aksResourceGroup)-cluster
    aksServicePrincipalSecret: $[dependencies.Keyvault.outputs['exportKeyvault.aksServicePrincipalSecret']]
    aksServerAppSecret: $[dependencies.Keyvault.outputs['exportKeyvault.aksServerAppSecret']]
  steps:
  - task: AzureCLI@1
    displayName: Check VNET prerequisites
    inputs:
      azureSubscription: $(serviceConnection)
      arguments: $(aksResourceGroup) $(aksVnetCidr) $(aksSubnetCidr)
      scriptPath: scripts/check-vnet-prerequisites.sh

  - task: AzureResourceGroupDeployment@2
    displayName: 'Deploy VNET'
    condition: not(variables['aksSubnetId'])
    inputs:
      azureSubscription: $(serviceConnection)
      action: 'Create Or Update Resource Group'
      resourceGroupName: $(aksResourceGroup)
      deploymentMode: 'Incremental'
      location: $(location)
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-vnet-template.json'
      overrideParameters: '-aksVnetName $(aksClusterName) 
        -aksVnetPrefix $(aksVnetCidr) 
        -aksSubnetName default 
        -aksSubnetPrefix $(aksSubnetCidr)'
      deploymentOutputs: 'vnetOutputs'

  - task: AzureCLI@1
    displayName: Parse ARM Outputs
    condition: not(variables['aksSubnetId'])
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: inlineScript
      inlineScript: |
        for row in $(echo '$(vnetOutputs)' | jq -c '. | to_entries[]'); do
          outputName=$(echo ${row} | jq -r ".key")
          outputValue=$(echo ${row} | jq -r ".value.value")
          echo "##vso[task.setvariable variable=${outputName}]${outputValue}"
        done

  - task: AzureResourceGroupDeployment@2
    displayName: 'Deploy AKS Cluster'
    inputs:
      azureSubscription: $(serviceConnection)
      action: 'Create Or Update Resource Group'
      resourceGroupName: $(aksResourceGroup)
      deploymentMode: 'Incremental'
      location: $(location)
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-aks-template.json'
      csmParametersFile: 'templates/arm-aks-parameters.json'
      overrideParameters: '-aksClusterName $(aksClusterName) 
        -aksVnetSubnetId $(aksSubnetId) 
        -aksServiceCidr $(aksServiceCidr) 
        -aksDnsServiceIp $(aksDnsServiceIp) 
        -servicePrincipalSecret $(aksServicePrincipalSecret) 
        -serverAppSecret $(aksServerAppSecret)'
      deploymentOutputs: 'aksOutputs'

  - task: AzureCLI@1
    displayName: Parse ARM Outputs
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: inlineScript
      inlineScript: |
        for row in $(echo '$(aksOutputs)' | jq -c '. | to_entries[]'); do
          outputName=$(echo ${row} | jq -r ".key")
          outputValue=$(echo ${row} | jq -r ".value.value")
          echo "##vso[task.setvariable variable=${outputName}]${outputValue}"
        done

  - task: AzureCLI@1
    displayName: 'Obtain AKS Admin access token.'
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: 'inlineScript'
      inlineScript: |
        az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --admin

  - task: AzureCLI@1
    displayName: 'Create Custom Namespaces'
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: 'inlineScript'
      inlineScript: |
        export NAMESPACE_NAME=$(adminNamespace)
        NS_DEPLOYMENT_PATH='deployments/namespaces.yml'
        envsubst < ${NS_DEPLOYMENT_PATH} > ${NS_DEPLOYMENT_PATH}.tmp && mv ${NS_DEPLOYMENT_PATH}.tmp ${NS_DEPLOYMENT_PATH}
        kubectl apply -f ${NS_DEPLOYMENT_PATH}

  - task: AzureCLI@1
    displayName: 'Bind admin role to "aks-cluster-admin" group'
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: 'inlineScript'
      inlineScript: |
        CLUSTER_GLOBAL_ADMINS_GROUP=$(az ad group list --query  "[?displayName=='aks-cluster-admins'].objectId" -o tsv)
        
        CLUSTER_ADMINS_GROUP_NAME="$(aksClusterName)-cluster-admins"
        CLUSTER_ADMIN_GROUP=$(az ad group list --query  "[?displayName=='${CLUSTER_ADMINS_GROUP_NAME}'].objectId" -o tsv)
        if [ -z "${CLUSTER_ADMIN_GROUP}" ]; then 
            echo "Cluster admin group doesn't exist, creating"
            CLUSTER_ADMIN_GROUP=$(az ad group create  --display-name ${CLUSTER_ADMINS_GROUP_NAME} --mail-nickname ${CLUSTER_ADMINS_GROUP_NAME} --query objectId -o tsv)
        fi
        
        cat roles/cluster-admin-role-binding.yml | \
          sed -e 's@${CLUSTER_ADMIN_GROUP}@'"$CLUSTER_ADMIN_GROUP"'@' | \
          sed -e 's@${CLUSTER_GLOBAL_ADMINS_GROUP}@'"$CLUSTER_GLOBAL_ADMINS_GROUP"'@' | \
          kubectl apply -f -

  - task: AzureCLI@1
    displayName: 'Bind developers roles'
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: 'inlineScript'
      inlineScript: |
        kubectl apply -f roles/developers-log-reader-role.yml
        DEVELOPERS_GROUP=$(az ad group list --query  "[?displayName=='developers'].objectId" -o tsv)
        if [ ! -z "${DEVELOPERS_GROUP}" ]; then          
          cat roles/developers-log-reader-binding.yml | sed -e 's@${DEVELOPERS_GROUP}@'"$DEVELOPERS_GROUP"'@' | kubectl apply -f -
        fi

  - task: HelmInstaller@0
    displayName: 'Install Helm Client $(helmVersion)'
    inputs:
        helmVersion: $(helmVersion)
        checkLatestHelmVersion: false
        installKubectl: false

  - task: AzureCLI@1
    displayName: 'Install Tiller $(helmVersion)'
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: 'inlineScript'
      inlineScript: |
        kubectl apply -f roles/helm-rbac-config.yml
        helm init --wait --service-account tiller --tiller-image gcr.io/kubernetes-helm/tiller:v$(helmVersion) --history-max=5 --kube-context '$(aksClusterName)-admin'

  - task: AzureResourceGroupDeployment@2
    displayName: 'Create Managed Identity for AKS'
    inputs:
      azureSubscription: $(serviceConnection)
      action: 'Create Or Update Resource Group'
      resourceGroupName: $(aksRGName)
      deploymentMode: 'Incremental'
      location: $(location)
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-mi-template.json'
      overrideParameters: '-resourceName $(aksClusterName)-mi'
      deploymentOutputs: 'miOutputs'

  - task: AzureCLI@1
    displayName: Parse ARM Outputs
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: inlineScript
      inlineScript: |
        for row in $(echo '$(miOutputs)' | jq -c '. | to_entries[]'); do
          outputName=$(echo ${row} | jq -r ".key")
          outputValue=$(echo ${row} | jq -r ".value.value")
          echo "##vso[task.setvariable variable=${outputName}]${outputValue}"
        done

  - task: AzureCLI@1
    displayName: 'Deploy AAD Pod Identity Operator, MIC:$(aadMicVersion) NMI:$(aadNmiVersion)'
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: 'inlineScript'
      inlineScript: |
        export IDENTITY_NAME=$(aksClusterName)-mi
        export IDENTITY_RESOURCE_ID=$(miResourceID)
        export IDENTITY_CLIENT_ID=$(miClientID)
        export IDENTITY_SELECTOR=$(aadSelector)
        export NMI_VERSION=$(aadNmiVersion)
        export MIC_VERSION=$(aadMicVersion)
        export NAMESPACE_NAME=$(adminNamespace)
        AAD_DEPLOYMENT_PATH='deployments/aad-pod-identity-rbac.yml'
        IDENTITY_PATH='deployments/aad-azure-identity.yml'
        IDENTITY_BINDING_PATH='deployments/aad-azure-Identity-binding.yml'      
        envsubst < ${AAD_DEPLOYMENT_PATH} > ${AAD_DEPLOYMENT_PATH}.tmp && mv ${AAD_DEPLOYMENT_PATH}.tmp ${AAD_DEPLOYMENT_PATH}
        kubectl apply -f ${AAD_DEPLOYMENT_PATH}
        envsubst < ${IDENTITY_PATH} > ${IDENTITY_PATH}.tmp && mv ${IDENTITY_PATH}.tmp ${IDENTITY_PATH}
        kubectl apply -f ${IDENTITY_PATH}
        envsubst < ${IDENTITY_BINDING_PATH} > ${IDENTITY_BINDING_PATH}.tmp && mv ${IDENTITY_BINDING_PATH}.tmp ${IDENTITY_BINDING_PATH}
        kubectl apply -f ${IDENTITY_BINDING_PATH}

  - task: AzureCLI@1
    displayName: 'Deploy KeyVault-FlexVolume $(kvFlexVolumeVersion)'
    inputs:
      azureSubscription: $(serviceConnection)
      scriptLocation: 'inlineScript'
      inlineScript: |
        export KV_VERSION=$(kvFlexVolumeVersion)
        export NAMESPACE_NAME=$(adminNamespace)
        KV_DEPLOYMENT_PATH='deployments/kv-flexvol-installer.yml'
        envsubst < ${KV_DEPLOYMENT_PATH} > ${KV_DEPLOYMENT_PATH}.tmp && mv ${KV_DEPLOYMENT_PATH}.tmp ${KV_DEPLOYMENT_PATH}
        kubectl apply -f ${KV_DEPLOYMENT_PATH}

- job: RunTests
  dependsOn: DeployAKS
  pool:
    name: 'Hosted VS2017'
  steps:
  - task: AzurePowerShell@3
    displayName: 'Run tests'
    condition: always()
    inputs:
      azureSubscription: $(serviceConnection)
      azurePowerShellVersion: latestVersion
      scriptType: 'inlineScript'
      inline: "Invoke-Pester @{Path= '$(Build.SourcesDirectory)/tests/*.tests.ps1' ;Parameters = @{ResourceGroupName='$(aksResourceGroup)'}} -OutputFile $(Build.SourcesDirectory)/TEST-Peering.xml -OutputFormat NUnitXML -EnableExit"
      timeoutInMinutes: 1
      
  - task: PublishTestResults@2
    displayName: 'Publish Environment Test Results **/TEST-*.xml'
    condition: always()
    inputs:
      testResultsFormat: NUnit
      timeoutInMinutes: 1